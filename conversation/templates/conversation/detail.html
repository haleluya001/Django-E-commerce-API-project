{% extends 'core/base.html' %}
{% load static %}

{% block title %}Conversation about {{ conversation.item.name }}{% endblock %}

{% block content %}
<div class="max-w-4xl mx-auto mt-6 p-6 bg-gray-100 dark:bg-gray-900 rounded-2xl shadow-xl flex flex-col space-y-6">

    <!-- Header -->
    <div class="flex items-center justify-between p-4 bg-white dark:bg-gray-800 shadow rounded-xl">
        <h1 class="text-2xl font-bold text-gray-800 dark:text-gray-100">Conversation about "{{ conversation.item.name }}"</h1>
        <span class="text-gray-500 dark:text-gray-400 text-sm">Started: {{ conversation.created_at|date:"M d, Y" }}</span>
    </div>

    <!-- Chat messages -->
    <div id="chat-container" class="flex flex-col space-y-4 p-4 bg-white dark:bg-gray-800 rounded-xl shadow-inner overflow-y-auto border border-gray-200 dark:border-gray-700" style="height: 70vh;">
        {% if conversation.messages.exists %}
            {% for message in conversation.messages.all %}
                <div class="flex {% if message.created_by == request.user %}justify-end{% else %}justify-start{% endif %} message-item">
                    <div class="max-w-[70%] p-3 rounded-2xl shadow-md transition transform hover:scale-[1.01]
                        {% if message.created_by == request.user %}bg-blue-500 text-white rounded-br-none{% else %}bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-100 rounded-bl-none border border-gray-200 dark:border-gray-600{% endif %}">

                        <p class="text-sm font-semibold mb-1
                            {% if message.created_by == request.user %}text-blue-100{% else %}text-gray-600 dark:text-gray-300{% endif %}">
                            {{ message.created_by.username }}
                        </p>
                        <p class="break-words whitespace-pre-wrap">{{ message.content }}</p>
                        <span class="text-xs mt-1 block
                            {% if message.created_by == request.user %}text-blue-200 text-right{% else %}text-gray-500 dark:text-gray-400 text-left{% endif %}">
                            {{ message.created_at|date:"H:i" }}
                        </span>
                    </div>
                </div>
            {% endfor %}
        {% else %}
            <p id="empty-message" class="text-gray-500 dark:text-gray-400 text-center mt-4">No messages yet. Start the conversation below!</p>
        {% endif %}
    </div>

    <!-- Message input (Real-time enabled) -->
    <form id="message-form" class="flex items-end space-x-4">
        {% csrf_token %}
        <textarea id="message-input" name="message" placeholder="Type your message here..." rows="1"
            class="flex-1 px-5 py-3 border-2 border-gray-300 dark:border-gray-600 rounded-xl resize-none
                   focus:outline-none focus:ring-4 focus:ring-blue-200 focus:border-blue-500
                   bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-100
                   transition-all duration-300 shadow-inner"
            required aria-label="Message input field"></textarea>

        <button type="submit" class="py-3 px-6 text-lg bg-blue-500 hover:bg-blue-600 rounded-xl text-white font-semibold shadow-lg transition transform hover:scale-105">
            Send
        </button>
    </form>

</div>

<script>
    const chatContainer = document.getElementById('chat-container');
    const messageForm = document.getElementById('message-form');
    const messageInput = document.getElementById('message-input');
    const emptyMessage = document.getElementById('empty-message');

    // Get Django context variables
    // IMPORTANT: conversation.id must be available in the template context
    const conversationId = {{ conversation.id }};
    const currentUsername = "{{ request.user.username }}";

    // Utility function to scroll to the bottom of the chat container
    const scrollToBottom = () => {
        if(chatContainer) {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
    };

    // 1. Initial scroll to bottom on page load
    window.onload = scrollToBottom;

    // 2. WebSocket Connection (Ensure Django Channels is set up on the backend)
    const chatSocket = new WebSocket(
        'ws://'
        + window.location.host
        + '/ws/chat/' // Verify this is your WebSocket URL pattern
        + conversationId
        + '/'
    );
    
    // 3. Helper function to render a message bubble
    const renderMessage = (message, username, created_at, isCurrentUser) => {
        // Remove the "No messages yet" placeholder if a message arrives
        if (emptyMessage && chatContainer.querySelectorAll('.message-item').length === 0) {
            emptyMessage.style.display = 'none';
        }

        // Define CSS classes based on sender, matching the Django template's styles
        const bubbleClasses = isCurrentUser
            ? "bg-blue-500 text-white rounded-br-none"
            : "bg-white dark:bg-gray-700 text-gray-800 dark:text-gray-100 rounded-bl-none border border-gray-200 dark:border-gray-600";
        
        const justifyClasses = isCurrentUser ? "justify-end" : "justify-start";
        
        const usernameColor = isCurrentUser ? "text-blue-100" : "text-gray-600 dark:text-gray-300";
        const timeClasses = isCurrentUser ? `text-blue-200 text-right` : `text-gray-500 dark:text-gray-400 text-left`;

        // Create the message HTML structure
        const messageHtml = `
            <div class="flex ${justifyClasses} message-item">
                <div class="max-w-[70%] p-3 rounded-2xl shadow-md transition transform hover:scale-[1.01] ${bubbleClasses}">
                    <p class="text-sm font-semibold mb-1 ${usernameColor}">${username}</p>
                    <p class="break-words whitespace-pre-wrap">${message.replace(/\n/g, '<br>')}</p>
                    <span class="text-xs mt-1 block ${timeClasses}">
                        ${created_at}
                    </span>
                </div>
            </div>
        `;

        // Append to chat container and scroll
        chatContainer.insertAdjacentHTML('beforeend', messageHtml);
        scrollToBottom();
    }


    // 4. Handle incoming messages (Real-time rendering from server broadcast)
    chatSocket.onmessage = function(e) {
        const data = JSON.parse(e.data);
        const message = data.message;
        const username = data.username;
        const created_at = data.created_at; // Expecting a formatted time string (e.g., '14:30')
        
        const isCurrentUser = (username === currentUsername);
        
        // Render the received message
        renderMessage(message, username, created_at, isCurrentUser);
    };


    // 5. Handle form submission (Send message via WebSocket & Optimistic Render)
    messageForm.addEventListener('submit', function(e) {
        e.preventDefault();

        const message = messageInput.value.trim();
        if (message === '') return; // Don't send empty messages

        // Send message to WebSocket
        chatSocket.send(JSON.stringify({
            'message': message
        }));

        // --- OPTIMISTIC RENDER: Immediately show the message the user just sent ---
        const now = new Date();
        const created_at_local = now.getHours().toString().padStart(2, '0') + ':' + now.getMinutes().toString().padStart(2, '0');
        
        renderMessage(message, currentUsername, created_at_local, true); // true for isCurrentUser

        // Clear the input field and reset height
        messageInput.value = '';
        messageInput.style.height = 'auto'; // Reset the height if it expanded

        // Optional: Re-focus on input for quick reply
        messageInput.focus();
    });

    chatSocket.onclose = function(e) {
        console.error('Chat socket closed unexpectedly');
    };

    // Optional: Auto-expand textarea height as user types
    messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });

</script>
{% endblock %}
